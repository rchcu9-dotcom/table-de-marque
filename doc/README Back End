ğŸ“˜ README â€“ Backend Table de Marque (NestJS + Architecture Hexagonale)
ğŸ¯ Introduction

Ce backend implÃ©mente une application modulaire en NestJS, suivant les principes :

de lâ€™architecture hexagonale (ports & adapters)

de la sÃ©paration stricte des responsabilitÃ©s (Domain â€” Application â€” Infrastructure)

de la validation via DTO

de la testabilitÃ© totale (unit tests + e2e)

dâ€™une future intÃ©gration Prisma + CI/CD

Lâ€™objectif est dâ€™avoir :

une base propre et durable

facile Ã  maintenir

testable

compatible CI

extensible pour gÃ©rer lâ€™ensemble de la table de marque hockey

ğŸ§± Architecture globale (ResponsabilitÃ©s)

Voici la vue en couches, organisationnelle :

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       Interface (HTTP)                   â”‚
â”‚         Controllers NestJS â†’ DTO â†’ appels Use Cases      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â–²                         â”‚
                â”‚                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Application Layer                      â”‚
â”‚  Use Cases (Create / Read / Update / Delete)             â”‚
â”‚  Orchestration du flux, sans logique mÃ©tier              â”‚
â”‚  DÃ©pend UNIQUEMENT de ports du domaine                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â–²                         â”‚
                â”‚                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       Domain Layer                       â”‚
â”‚  EntitÃ©s mÃ©tier (Matchâ€¦)                                 â”‚
â”‚  Ports (interfaces repositories)                         â”‚
â”‚  IndÃ©pendant de Nest / Prisma / framework                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â–²                         â”‚
                â”‚                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Infrastructure Layer                    â”‚
â”‚  Adapters :                                              â”‚
â”‚  - Repositories (Prisma)                                 â”‚
â”‚  - HTTP (Controllers)                                    â”‚
â”‚  - Database (Prisma ORM)                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ”„ Architecture FLUX (exÃ©cution dâ€™une requÃªte)
Client HTTP (POST /matches)
           â”‚
           â–¼
     Controller
           â”‚ valide DTO
           â–¼
       Use Case
           â”‚ transforme DTO â†’ EntitÃ© Domain
           â–¼
   Repository (port)
           â”‚
    Adapter (Prisma)
           â”‚
         Base SQL

ğŸ¯ IdÃ©e clÃ© :

Les Use Cases ne dÃ©pendent jamais dâ€™une base de donnÃ©es.
Ils dÃ©pendent dâ€™une INTERFACE (port).
Câ€™est lâ€™infrastructure qui fournit lâ€™adapter (Prisma).

ğŸ“ Structure du projet
src/
 â”œâ”€â”€ domain/
 â”‚     â””â”€â”€ match/
 â”‚          â”œâ”€â”€ entities/
 â”‚          â”‚     â””â”€â”€ match.entity.ts
 â”‚          â””â”€â”€ repositories/
 â”‚                â”œâ”€â”€ match.repository.ts (port)
 â”‚                â””â”€â”€ tokens.ts
 â”‚
 â”œâ”€â”€ application/
 â”‚     â””â”€â”€ match/
 â”‚           â”œâ”€â”€ dto/
 â”‚           â”‚     â”œâ”€â”€ create-match.dto.ts
 â”‚           â”‚     â”œâ”€â”€ update-match.dto.ts
 â”‚           â”‚     â””â”€â”€ delete-match.dto.ts
 â”‚           â””â”€â”€ use-cases/
 â”‚                 â”œâ”€â”€ create-match.usecase.ts
 â”‚                 â”œâ”€â”€ get-all-matches.usecase.ts
 â”‚                 â”œâ”€â”€ get-match-by-id.usecase.ts
 â”‚                 â”œâ”€â”€ update-match.usecase.ts
 â”‚                 â””â”€â”€ delete-match.usecase.ts
 â”‚
 â””â”€â”€ infrastructure/
       â”œâ”€â”€ http/
       â”‚     â””â”€â”€ match/
       â”‚           â”œâ”€â”€ match.controller.ts
       â”‚           â””â”€â”€ match.module.ts
       â””â”€â”€ persistence/
             â””â”€â”€ prisma/
                   â”œâ”€â”€ prisma.service.ts
                   â””â”€â”€ prisma-match.repository.ts (Ã  venir)

ğŸ§© DTO (Data Transfer Objects)

Les DTO dÃ©finissent la forme des donnÃ©es entrantes et assurent la validation.

CreateMatchDto

UpdateMatchDto

DeleteMatchDto

Ces fichiers vivent dans :

src/application/match/dto/


RÃ´le des DTO :

ContrÃ´ler la structure dâ€™entrÃ©e (validation)

Ne pas contenir de logique mÃ©tier

Ne pas dÃ©pendre du domaine

ğŸš¦ Use Cases

Les Use Cases reprÃ©sentent les actions possibles sur les matchs :

CreateMatchUseCase

GetAllMatchesUseCase

GetMatchByIdUseCase

UpdateMatchUseCase

DeleteMatchUseCase

Un Use Case :

est @Injectable()

dÃ©pend du port MatchRepository

orchestre le flux entre DTO â†” EntitÃ© â†” Repository

ne connaÃ®t pas Prisma, ni HTTP

ğŸ’¾ Domain (EntitÃ©s + Ports)

Lâ€™entitÃ© mÃ©tier principale est :

Match {
  id: string
  date: Date
  teamA: string
  teamB: string
  status: 'planned' | 'ongoing' | 'finished' | 'deleted'
}


Le domaine dÃ©finit le port (interface) :

export abstract class MatchRepository {
  abstract create(match: Match): Promise<Match>;
  abstract findAll(): Promise<Match[]>;
  abstract findById(id: string): Promise<Match | null>;
  abstract update(match: Match): Promise<Match>;
}


Lâ€™infrastructure fournit lâ€™implÃ©mentation (Prisma).

ğŸ›  HTTP Layer (Controllers)

Un controller :

reÃ§oit les requÃªtes

valide le DTO

appelle le bon use case

ne contient aucune logique mÃ©tier

Exemple (simplifiÃ©) :

@Post()
create(@Body() dto: CreateMatchDto) {
  return this.createMatchUseCase.execute(dto);
}

ğŸ—„ Module NestJS (MatchModule)

Il relie :

controllers

use cases

repository (via token)

adapter infrastructure

Câ€™est le cÅ“ur de lâ€™injection de dÃ©pendances.

ğŸ§ª Tests
âœ” Tests Unitaires (layer application)

SituÃ©s dans :

test/application/match/*.spec.ts


Ils :

mockent le repository

testent uniquement le use case

ne touchent pas HTTP / Prisma

âœ” Tests E2E (HTTP complet)

SituÃ©s dans :

test/matches/*.e2e-spec.ts


Ils testent toute la stack HTTP, avec un repository mÃ©moire.

Tests fournis :

create-match.e2e-spec.ts

get-all-matches.e2e-spec.ts

get-match-by-id.e2e-spec.ts

update-match.e2e-spec.ts

delete-match.e2e-spec.ts

Les 5 passent ğŸ’š.

ğŸš€ Commandes utiles
Lancer le serveur Nest :
npm run start:dev

Lancer les tests unitaires :
npm test

Lancer les tests E2E :
npm run test:e2e

GÃ©nÃ©rer Prisma :
npx prisma generate

Lancer Prisma Studio :
npx prisma studio

ğŸ“Œ CRUD complet (rÃ©sumÃ©)
POST   /matches       â†’ CreateMatchDto â†’ createMatchUseCase
GET    /matches       â†’ getAllMatchesUseCase
GET    /matches/:id   â†’ getMatchByIdUseCase
PUT    /matches/:id   â†’ UpdateMatchDto â†’ updateMatchUseCase
DELETE /matches/:id   â†’ DeleteMatchDto â†’ deleteMatchUseCase